<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Neon Dash Runner</title>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #1a2a6c, #000000 55%);
      color: #f5f5f5;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #game-container {
      position: relative;
      width: min(900px, 100vw - 24px);
      aspect-ratio: 16 / 9;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
      background: linear-gradient(to top, #020617, #020617 60%, #0f172a);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(to top, #020617, #020617 60%, #0f172a);
    }

    #hud {
      pointer-events: none;
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 10px 16px;
    }

    #hud-top {
      display: flex;
      justify-content: space-between;
      font-size: 0.95rem;
      text-shadow: 0 0 6px rgba(0, 0, 0, 0.6);
    }

    .badge {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.4);
      backdrop-filter: blur(8px);
    }

    #center-message {
      pointer-events: auto;
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 0 24px;
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
    }

    #title {
      font-size: 2rem;
      margin-bottom: 12px;
      letter-spacing: 0.06em;
    }

    #subtitle {
      font-size: 0.95rem;
      opacity: 0.85;
      max-width: 480px;
      margin-bottom: 16px;
    }

    .btn {
      pointer-events: auto;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-top: 8px;
      padding: 9px 16px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #22c55e, #a3e635);
      color: #020617;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(34, 197, 94, 0.5);
      transition: transform 0.1s ease, box-shadow 0.1s ease,
        filter 0.15s ease;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 40px rgba(34, 197, 94, 0.7);
      filter: brightness(1.05);
    }

    .btn:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 5px 16px rgba(34, 197, 94, 0.4);
    }

    #hint {
      font-size: 0.8rem;
      opacity: 0.8;
      margin-top: 8px;
    }

    #dash-indicator {
      margin-top: 6px;
      font-size: 0.8rem;
      opacity: 0.85;
    }

    #dash-bar-bg {
      position: relative;
      width: 120px;
      height: 8px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.8);
      overflow: hidden;
      margin-top: 2px;
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    #dash-bar-fill {
      position: absolute;
      inset: 0;
      width: 0%;
      background: linear-gradient(90deg, #f97316, #facc15);
      transition: width 0.05s linear;
    }

    #touch-controls {
      pointer-events: auto;
      position: absolute;
      inset: 0;
      display: none;
      justify-content: space-between;
      align-items: flex-end;
      padding: 0 14px 14px;
      font-size: 0.7rem;
      color: rgba(226, 232, 240, 0.9);
    }

    .touch-btn {
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(15, 23, 42, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.6);
      backdrop-filter: blur(8px);
    }

    @media (pointer: coarse) {
      #touch-controls {
        display: flex;
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas" width="900" height="506"></canvas>

    <div id="hud">
      <div id="hud-top">
        <div class="badge" id="score-text">Score: 0</div>
        <div style="display:flex;gap:8px;align-items:center;">
          <div class="badge" id="best-text">Best: 0</div>
        </div>
      </div>

      <div id="center-message">
        <div id="title">NEON DASH RUNNER</div>
        <div id="subtitle">
          Dodge red obstacles, collect golden orbs, and survive as the
          speed ramps up. You can double-jump and trigger a brief
          slow-motion dash.
        </div>
        <button class="btn" id="play-button">
          ▶ Start Run
        </button>
        <div id="hint">
          Keyboard: SPACE / W / ↑ to jump — SHIFT / D to dash<br />
          Touch: tap left side to jump, right side to dash
        </div>
      </div>

      <div
        style="position:absolute;bottom:10px;left:50%;transform:translateX(-50%);text-align:center;font-size:0.75rem;opacity:0.8;"
      >
        <div id="dash-indicator">
          Dash ready:
          <span id="dash-status-text">YES</span>
        </div>
        <div id="dash-bar-bg">
          <div id="dash-bar-fill"></div>
        </div>
      </div>
    </div>

    <div id="touch-controls">
      <div class="touch-btn" id="jump-touch">Tap left: JUMP</div>
      <div class="touch-btn" id="dash-touch">Tap right: DASH</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const scoreText = document.getElementById("score-text");
    const bestText = document.getElementById("best-text");
    const centerMessage = document.getElementById("center-message");
    const playButton = document.getElementById("play-button");
    const dashStatusText = document.getElementById("dash-status-text");
    const dashBarFill = document.getElementById("dash-bar-fill");

    const jumpTouch = document.getElementById("jump-touch");
    const dashTouch = document.getElementById("dash-touch");

    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;
    const GROUND_Y = HEIGHT - 80;

    const GAME_STATE = {
      MENU: "menu",
      PLAYING: "playing",
      GAME_OVER: "gameover",
    };

    let state = GAME_STATE.MENU;

    let player;
    let obstacles;
    let coins;

    let lastTime = 0;
    let elapsed = 0;
    let score = 0;
    let bestScore = 0;

    let obstacleSpawnTimer = 0;
    let coinSpawnTimer = 0;

    const gravity = 2300;
    const jumpStrength = 900;

    let dashCooldown = 0;
    let dashTimer = 0;
    const DASH_DURATION = 0.5;
    const DASH_COOLDOWN = 4.0;
    const DASH_SLOWMO_FACTOR = 0.45;

    const keys = {
      jump: false,
      dash: false,
    };

    function loadBestScore() {
      try {
        const value = localStorage.getItem("neonDashBest");
        if (value !== null) {
          bestScore = parseInt(value, 10) || 0;
        }
      } catch (e) {
        bestScore = 0;
      }
      bestText.textContent = "Best: " + bestScore.toFixed(0);
    }

    function saveBestScore() {
      try {
        localStorage.setItem("neonDashBest", String(bestScore));
      } catch (e) {}
    }

    function createPlayer() {
      return {
        x: 120,
        y: GROUND_Y - 60,
        width: 50,
        height: 60,
        vy: 0,
        onGround: true,
        doubleJumpAvailable: true,
      };
    }

    function resetGame() {
      player = createPlayer();
      obstacles = [];
      coins = [];

      elapsed = 0;
      score = 0;

      obstacleSpawnTimer = 0.5;
      coinSpawnTimer = 1.2;

      dashCooldown = 0;
      dashTimer = 0;

      centerMessage.style.display = "none";
      updateHUD();
    }

    function updateHUD() {
      scoreText.textContent = "Score: " + score.toFixed(0);
      bestText.textContent = "Best: " + bestScore.toFixed(0);

      const dashReady = dashCooldown <= 0 && dashTimer <= 0;
      dashStatusText.textContent = dashReady ? "YES" : "…cooling";
      dashStatusText.style.color = dashReady ? "#bbf7d0" : "#fed7aa";

      let fraction;
      if (dashTimer > 0) {
        fraction = 1;
      } else {
        fraction = 1 - Math.min(Math.max(dashCooldown / DASH_COOLDOWN, 0), 1);
      }
      dashBarFill.style.width = (fraction * 100).toFixed(1) + "%";
    }

    function spawnObstacle(difficulty) {
      const baseWidth = 40 + Math.random() * 40 * difficulty;
      const height = 40 + Math.random() * 60 * difficulty;
      const gapOffset = Math.random() * 40 * difficulty;

      const obstacle = {
        x: WIDTH + 40,
        y: GROUND_Y - height + gapOffset * 0.25,
        width: baseWidth,
        height: height,
        speed: 260 + difficulty * 160,
      };

      obstacles.push(obstacle);
    }

    function spawnCoin(difficulty) {
      const radius = 12;
      const y =
        GROUND_Y - (100 + Math.random() * (170 + difficulty * 40));
      const coin = {
        x: WIDTH + 40,
        y: y,
        radius: radius,
        speed: 230 + difficulty * 140,
        collected: false,
      };
      coins.push(coin);
    }

    function rectIntersect(ax, ay, aw, ah, bx, by, bw, bh) {
      return (
        ax < bx + bw &&
        ax + aw > bx &&
        ay < by + bh &&
        ay + ah > by
      );
    }

    function circleRectIntersect(cx, cy, radius, rx, ry, rw, rh) {
      const closestX = Math.max(rx, Math.min(cx, rx + rw));
      const closestY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - closestX;
      const dy = cy - closestY;
      return dx * dx + dy * dy <= radius * radius;
    }

    function update(dtRaw) {
      let dt = dtRaw;

      const inDash = dashTimer > 0;
      if (inDash) {
        dt *= DASH_SLOWMO_FACTOR;
      }

      elapsed += dt;

      const difficulty = 1 + elapsed * 0.07;

      if (dashTimer > 0) {
        dashTimer -= dtRaw;
        if (dashTimer <= 0) {
          dashTimer = 0;
        }
      } else if (dashCooldown > 0) {
        dashCooldown -= dtRaw;
        if (dashCooldown < 0) dashCooldown = 0;
      }

      if (keys.jump) {
        handleJump();
        keys.jump = false;
      }
      if (keys.dash) {
        handleDash();
        keys.dash = false;
      }

      player.vy += gravity * dt;
      player.y += player.vy * dt;

      if (player.y + player.height >= GROUND_Y) {
        player.y = GROUND_Y - player.height;
        player.vy = 0;
        if (!player.onGround) {
          player.onGround = true;
        }
        player.doubleJumpAvailable = true;
      }

      obstacleSpawnTimer -= dt;
      if (obstacleSpawnTimer <= 0) {
        const base = 0.95;
        const minInterval = 0.42;
        const scaled = base / (0.6 + Math.min(difficulty, 3));
        const jitter = (Math.random() * 0.4 - 0.2) * scaled;
        obstacleSpawnTimer = Math.max(minInterval, scaled + jitter);
        spawnObstacle(difficulty);
      }

      coinSpawnTimer -= dt;
      if (coinSpawnTimer <= 0) {
        const baseCoin = 1.1;
        const minCoinInterval = 0.6;
        const scaledCoin = baseCoin / (0.8 + Math.min(difficulty, 2.5));
        const jitterCoin = (Math.random() * 0.6 - 0.3) * scaledCoin;
        coinSpawnTimer = Math.max(minCoinInterval, scaledCoin + jitterCoin);
        spawnCoin(difficulty);
      }

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.x -= o.speed * dt;
        if (o.x + o.width < -40) {
          obstacles.splice(i, 1);
        }
      }

      for (let i = coins.length - 1; i >= 0; i--) {
        const c = coins[i];
        c.x -= c.speed * dt;
        if (c.x + c.radius < -40 || c.collected) {
          coins.splice(i, 1);
        }
      }

      const playerHitbox = {
        x: player.x + 6,
        y: player.y + 6,
        width: player.width - 12,
        height: player.height - 12,
      };

      if (!inDash) {
        for (let i = 0; i < obstacles.length; i++) {
          const o = obstacles[i];
          if (
            rectIntersect(
              playerHitbox.x,
              playerHitbox.y,
              playerHitbox.width,
              playerHitbox.height,
              o.x,
              o.y,
              o.width,
              o.height
            )
          ) {
            handleGameOver();
            return;
          }
        }
      }

      for (let i = 0; i < coins.length; i++) {
        const c = coins[i];
        if (
          circleRectIntersect(
            c.x,
            c.y,
            c.radius,
            playerHitbox.x,
            playerHitbox.y,
            playerHitbox.width,
            playerHitbox.height
          )
        ) {
          c.collected = true;
          const bonus = 18 + Math.random() * 10;
          score += bonus;
        }
      }

      score += dt * (12 + (difficulty - 1) * 4);

      if (score > bestScore) {
        bestScore = score;
        saveBestScore();
      }

      updateHUD();
    }

    function drawBackgroundLayer() {
      ctx.fillStyle = "#020617";
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      const grad = ctx.createLinearGradient(0, GROUND_Y + 40, 0, HEIGHT);
      grad.addColorStop(0, "#020617");
      grad.addColorStop(1, "#0f172a");
      ctx.fillStyle = grad;
      ctx.fillRect(0, GROUND_Y, WIDTH, HEIGHT - GROUND_Y);

      ctx.strokeStyle = "rgba(148, 163, 184, 0.18)";
      ctx.lineWidth = 1;
      const spacing = 40;
      const offset = (elapsed * 120) % spacing;
      for (let x = -spacing; x < WIDTH + spacing; x += spacing) {
        ctx.beginPath();
        ctx.moveTo(x + offset, GROUND_Y);
        ctx.lineTo(x + spacing * 0.25 + offset, HEIGHT);
        ctx.stroke();
      }
    }

    function drawPlayer() {
      const glow = dashTimer > 0 ? "#f97316" : "#22c55e";

      ctx.save();
      ctx.shadowColor = glow;
      ctx.shadowBlur = dashTimer > 0 ? 30 : 18;
      ctx.fillStyle = "#0f172a";
      ctx.strokeStyle = "#22c55e";
      ctx.lineWidth = 2.5;

      ctx.beginPath();
      ctx.roundRect(
        player.x,
        player.y,
        player.width,
        player.height,
        10
      );
      ctx.fill();
      ctx.stroke();

      const eyeY = player.y + player.height * 0.32;
      const progress = (Math.sin(elapsed * 9) + 1) * 0.5;
      const eyeXOffset = 8 + progress * 12;

      ctx.fillStyle = "#e5e7eb";
      ctx.beginPath();
      ctx.arc(
        player.x + player.width * 0.2 + eyeXOffset,
        eyeY,
        4.5,
        0,
        Math.PI * 2
      );
      ctx.fill();

      const mouthWidth = 18;
      ctx.strokeStyle = "#a5b4fc";
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      ctx.moveTo(
        player.x + player.width * 0.2 + eyeXOffset - mouthWidth / 2,
        player.y + player.height * 0.65
      );
      ctx.quadraticCurveTo(
        player.x + player.width * 0.5 + eyeXOffset * 0.3,
        player.y + player.height * 0.74,
        player.x + player.width * 0.2 + eyeXOffset + mouthWidth / 2,
        player.y + player.height * 0.65
      );
      ctx.stroke();

      ctx.restore();
    }

    function drawObstacles() {
      for (const o of obstacles) {
        const grad = ctx.createLinearGradient(
          o.x,
          o.y,
          o.x + o.width,
          o.y + o.height
        );
        grad.addColorStop(0, "#b91c1c");
        grad.addColorStop(1, "#f97316");

        ctx.save();
        ctx.shadowColor = "#ef4444";
        ctx.shadowBlur = 20;
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.roundRect(
          o.x,
          o.y,
          o.width,
          o.height,
          10
        );
        ctx.fill();
        ctx.restore();
      }
    }

    function drawCoins() {
      for (const c of coins) {
        ctx.save();
        ctx.shadowColor = "#facc15";
        ctx.shadowBlur = 18;

        const grad = ctx.createRadialGradient(
          c.x,
          c.y,
          4,
          c.x,
          c.y,
          c.radius + 4
        );
        grad.addColorStop(0, "#fef9c3");
        grad.addColorStop(0.4, "#facc15");
        grad.addColorStop(1, "#a16207");

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    }

    function drawGround() {
      ctx.fillStyle = "#020617";
      ctx.fillRect(0, GROUND_Y + 18, WIDTH, HEIGHT);

      ctx.strokeStyle = "rgba(148, 163, 184, 0.7)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y);
      ctx.lineTo(WIDTH, GROUND_Y);
      ctx.stroke();
    }

    function render() {
      drawBackgroundLayer();
      drawCoins();
      drawObstacles();
      drawGround();
      drawPlayer();
    }

    function handleJump() {
      if (player.onGround) {
        player.vy = -jumpStrength;
        player.onGround = false;
      } else if (player.doubleJumpAvailable) {
        player.vy = -jumpStrength * 0.9;
        player.doubleJumpAvailable = false;
      }
    }

    function handleDash() {
      if (dashCooldown <= 0 && dashTimer <= 0) {
        dashTimer = DASH_DURATION;
        dashCooldown = DASH_COOLDOWN;
      }
    }

    function handleGameOver() {
      state = GAME_STATE.GAME_OVER;

      updateHUD();

      centerMessage.style.display = "flex";
      centerMessage.innerHTML = \`
        <div id="title">GAME OVER</div>
        <div id="subtitle">
          Final score: <b>\${score.toFixed(0)}</b><br />
          Best score: <b>\${bestScore.toFixed(0)}</b>
        </div>
        <button class="btn" id="play-button">↻ Play Again</button>
        <div id="hint">Tip: use double jumps to chain over multiple obstacles, and save your dash for emergencies.</div>
      \`;

      const btn = document.getElementById("play-button");
      btn.addEventListener("click", () => {
        state = GAME_STATE.PLAYING;
        centerMessage.style.display = "none";
        resetGame();
      });
    }

    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      if (state === GAME_STATE.PLAYING) {
        update(dt);
        render();
      } else {
        render();
      }

      requestAnimationFrame(gameLoop);
    }

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space" || e.code === "KeyW" || e.code === "ArrowUp") {
        e.preventDefault();
        if (state === GAME_STATE.MENU) {
          state = GAME_STATE.PLAYING;
          resetGame();
        } else if (state === GAME_STATE.PLAYING) {
          keys.jump = true;
        } else if (state === GAME_STATE.GAME_OVER) {
          state = GAME_STATE.PLAYING;
          resetGame();
        }
      }

      if (
        e.code === "ShiftLeft" ||
        e.code === "ShiftRight" ||
        e.code === "KeyD"
      ) {
        if (state === GAME_STATE.PLAYING) {
          keys.dash = true;
        }
      }
    });

    canvas.addEventListener("pointerdown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;

      if (state === GAME_STATE.MENU) {
        state = GAME_STATE.PLAYING;
        resetGame();
        return;
      }

      if (state === GAME_STATE.GAME_OVER) {
        state = GAME_STATE.PLAYING;
        resetGame();
        return;
      }

      if (state === GAME_STATE.PLAYING) {
        const middle = rect.width / 2;
        if (x < middle) {
          keys.jump = true;
        } else {
          keys.dash = true;
        }
      }
    });

    jumpTouch.addEventListener("pointerdown", (e) => {
      e.stopPropagation();
      if (state === GAME_STATE.PLAYING) {
        keys.jump = true;
      }
    });

    dashTouch.addEventListener("pointerdown", (e) => {
      e.stopPropagation();
      if (state === GAME_STATE.PLAYING) {
        keys.dash = true;
      }
    });

    playButton.addEventListener("click", () => {
      state = GAME_STATE.PLAYING;
      resetGame();
    });

    loadBestScore();
    resetGame();
    state = GAME_STATE.MENU;
    centerMessage.style.display = "flex";
    lastTime = 0;
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
